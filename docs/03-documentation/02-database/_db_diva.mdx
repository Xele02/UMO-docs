
import db_struct from "@site/static/data/database/diva/diva.struct.json";
import db_data from "@site/static/data/database/diva/diva.data.json";
import fb_data from "@site/static/data/database/diva/diva.fb.json";
import fb_schema from "@site/static/data/database/diva/diva.fb.struct.json";

import { TreeTable } from 'primereact/treetable';
import { Column } from 'primereact/column';
import { PrimeReactProvider } from 'primereact/api';
import "primereact/resources/themes/lara-light-cyan/theme.css";

import logger from '@docusaurus/logger';

export function getReaders(iterator_owner, path)
{
    const readerList = path.split('|');
    return readerList.map(reader => {
        
        const splitReaderPath = reader.split("/");
        var readerRet = {fb_struct:["",iterator_owner.fb_struct], fb_data:iterator_owner.fb_data};
        for(var rp of splitReaderPath)
        {
            if(!readerRet.fb_struct?.[1]?.properties)
            {
                throw new Error("Current fb struct doesn't contain properties field looking for "+rp+", searching "+reader+" "+JSON.stringify(readerRet.fb_struct));
                return null;
            }
            var tmpStruct = Object.entries(readerRet.fb_struct[1].properties).find(p => p[1].reader_prop == rp);
            if(!tmpStruct)
            {
                throw new Error("fb struct doesn't contain reader prop "+rp+" "+JSON.stringify(readerRet.fb_struct[1]));
                return null;
            }
            readerRet.fb_struct = tmpStruct;
            readerRet.fb_data = readerRet.fb_data[tmpStruct[0]];
        }
        return readerRet;
    });
}

export function iterator_move(iterator, path)
{
    const splitPath = path.toString().split('/');

    var res = { ...iterator };
    for(var p of splitPath)
    {
        if(p == ".")
            continue;
        if(res.db_struct.type == "list")
        {
            const idx = parseInt(p);

            if(res.db_struct.member_readerDisplay == "PropagateReader")
            {
                res.fb_data = res.fb_data;
                res.fb_struct = res.fb_struct;
            }
            else
            {
                if(!res.fb_struct.items)
                {
                    throw new Error("Current fb struct doesn't contain item field for "+p+" "+JSON.stringify(res.fb_struct));
                    return null;
                }
                res.fb_data = res.fb_data[idx];
                res.fb_struct = res.fb_struct.items[0];
            }
            res.db_data = res.db_data[idx];
            res.db_struct = res.db_struct.innerType;
            continue;
        }
        else if(res.db_struct.type == "class")
        {
            if(!(p in res.db_data))
            {
                throw new Error("Current db data doesn't contain "+p+" "+JSON.stringify(res));
                return null;
            }
            if(!res.db_struct.members)
            {
                throw new Error("Current db struct doesn't contain members field "+JSON.stringify(res.db_struct));
                return null;
            }
            var db_struct = res.db_struct.members.find(m => m.member_name == p);
            if(!db_struct)
            {
                throw new Error("Current db struct doesn't contain "+p+" "+JSON.stringify(res));
                return null;
            }
            res.db_data = res.db_data[p];
            res.db_struct = db_struct;

            // Setup fb
            if(res.db_struct.member_reader && res.db_struct.member_reader != "")
            {
                res.readers = getReaders(res, res.db_struct.member_reader);
                if(res.readers.length == 0)
                {
                    throw new Error("no reader for "+p+" "+JSON.stringify(res));
                    return null;
                }
                if(!res.readers[0].fb_struct)
                {
                    throw new Error("error in reader struct "+JSON.stringify(res.readers));
                    return null;
                }
                res.fb_struct = res.readers[0].fb_struct[1];
                res.fb_data = res.readers[0].fb_data;
            }
            if(res.db_struct.member_reader_child && res.db_struct.member_reader_child != "")
            {
                var childReader = getReaders(res, res.db_struct.member_reader_child);
                if(childReader.length == 0)
                {
                    throw new Error("no child reader for "+p+" "+JSON.stringify(res));
                }
                if(!childReader[0].fb_struct)
                {
                    throw new Error("error in child reader struct "+JSON.stringify(childReader));
                }
                res.fb_struct = childReader[0].fb_struct[1];
                res.fb_data = childReader[0].fb_data;
            }

            continue;
        }

        throw new Error("Can move for path "+p+" "+JSON.stringify(res));
        return null;
    }

    return res;
}

import { Panel } from 'primereact/panel';

export const DbPropSource = ({member_data, key_}) =>
{
    var readers = member_data.readers;
    if(member_data.db_struct.member_readerDisplay?.startsWith("DivaStat"))
    {
        const displayData = member_data.db_struct.member_readerDisplay.split("_");
        const statType = parseInt(displayData[1]);
        const keys = key_.split('-');
        const idx = parseInt(keys[keys.length - 2]);
        if(!member_data.readers?.[1])
            return "";
        if(idx == 0)
        {
            readers = [member_data.readers[0]];
        }
        else
        {
            const type = member_data.readers[1].fb_data[(idx - 1)*2];
            if(type != statType)
                return "";
            const val = member_data.readers[1].fb_data[(idx - 1)*2 + 1];
            const dataReader = {
                fb_struct : [
                    member_data.readers[1].fb_struct[0] + "["+((idx - 1)*2)+"]"+" & ["+((idx - 1)*2 + 1)+"]",
                    {
                        reader_prop : member_data.readers[1].fb_struct[1].reader_prop + "["+((idx - 1)*2)+"]"+" & ["+((idx - 1)*2 + 1)+"]"
                    }
                ],
                fb_data_forced : <>{type} {val}<br />Stat +{val}</>
            }
            readers = [dataReader];
        }
    }
    return readers.map(reader => {
        if(!reader.fb_struct?.[1].reader_prop)
            return "";
        const fbStructProp = reader.fb_struct;
        const subData = reader.fb_data_forced ?? (typeof(reader.fb_data) != "array" && typeof(reader.fb_data) != "object" ? reader.fb_data : typeof(reader.fb_data));
        return (<><br /><strong>Reader</strong> : {fbStructProp?.[1].reader_prop}<br />
            <strong>Database property</strong> : {fbStructProp?.[0] || ""}<br />
            <strong>Raw value</strong> : {subData}
        </>);
    });
}

export function generateNodesObject(iterator, prefix)
{
    return Object.entries(iterator.db_data).map(k => {
        const member_it = iterator_move(iterator, k[0])
        const key = prefix+k[0];
        const prefix_ = key+'-';
        const varNames = k[0].split('_');
        const name = member_it.db_struct.member_readableName && member_it.db_struct.member_readableName != "" ? member_it.db_struct.member_readableName : (varNames.length > 0 ? varNames[1] : varNames[0]);
        const header = member_it.db_struct.member_desc?.split('\n')[0]
        const additional_desc = member_it.db_struct.member_desc?.split('\n').splice(1).map(k => { return (<>{k}<br /></>); });
        const desc = (<>
            <Panel collapsed='true' header={header}  toggleable>
                {additional_desc}
                <strong>Property</strong> : {k[0]}<br />
                <strong>Type</strong> : {member_it.db_struct.type}
                <DbPropSource member_data={member_it} key_={key} />
            </Panel></>);
        if(member_it.db_struct.type == "list")
            return {key:key, data: {name:name, desc:desc, prop:{full:k[0]}}, type:'data', children:generateNodesArray(member_it, prefix_)};
        else if(member_it.db_struct.type == "class")
            return {key:key, data: {name:name, desc:desc, prop:{full:k[0]}}, type:'data', children:generateNodesObject(member_it, prefix_)};
        else
            return {key:key, data: {name:name, desc:desc, prop:{full:k[0]}, value:k[1] }, type:'data'};
    }
    );
}

export function generateNodesArray(iterator, prefix)
{
    const dataStruct = iterator.db_struct.innerType;
    return iterator.db_data.map((k, idx) => {
        const member_it = iterator_move(iterator, idx)
        const key = prefix+idx.toString()
        const prefix_ = key+'-';
        if(dataStruct.type == "list")
            return {key:key, data: {name:idx}, type:'array_idx', children:generateNodesArray(member_it, prefix_)};
        else if(dataStruct.type == "class")
            return {key:key, data: {name:idx}, type:'array_idx', children:generateNodesObject(member_it, prefix_)};
        else
            return {key:key, data: { name:idx, value:k[1] }, type:'array_idx'};
    });
}

export function generateNodes(iterator)
{
    /*
    format : 
    [
        {
            key: 'X-X-X',
            data: {
                name:
                value:
            },
            children: [
                ...
            ]
        }
    ]
    
    */

    return generateNodesObject(iterator, '');
}

export const nameBodyTemplate = (rowData) =>
{
    if(rowData.type == 'data')
        return (<code>{rowData.data.prop.full}</code>);
    return "";
}

export const DisplayData = ({datas, path}) =>
{
    const it = iterator_move(datas, path);

    const nodes = generateNodes(it);

    return (<TreeTable value={nodes} resizableColumns  filterDisplay='menu' filterMode="lenient" tableStyle={{ minWidth: '50rem' }}>
        <Column field="name" header="Name" frozen expander filter filterMatchMode="contains" />
        <Column field="value" header="Value" filt_er filterMatchMode="contains" />
        <Column field="desc" header="Description" filter filterMatchMode="contains" />
    </TreeTable>);
}

export const db_iterator = {
    db_struct:db_struct,
    db_data:db_data,
    fb_struct:fb_schema,
    fb_data:fb_data
};

<PrimeReactProvider>
<DisplayData datas={db_iterator} path="." />
</PrimeReactProvider>
